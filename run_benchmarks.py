import multipers as mp
from multipers.simplex_tree_multi import SimplexTreeMulti_type
from pathlib import Path
import numpy as np
import shutil
import subprocess
import time

def get_scc_filtration_size(file_path: str | Path) -> int:
    # Read the sizes of each dimension from the SCC file generated by rhomboidtiling
    with open(file_path, "r") as f:
        for current_line, line in enumerate(f):
            if current_line == 3:
                sizes = list(map(int, line.strip().split()))
                return sum(sizes) 

def get_kcritical_simplextree_size(st: SimplexTreeMulti_type) -> int:
    # Since Delaunay core is multi-critical, we count all critical filtration values 
    return sum(len(x[1]) for x in st.get_simplices())

def benchmark(X: np.ndarray, k_max: int) -> dict:
    results = {}

    # Delaunay core bifiltration
    print(f"Computing Delaunay core...")
    t_start = time.time()
    st = mp.filtrations.CoreDelaunay(X, ks=range(1, k_max + 1))
    t_end = time.time()
    core_delaunay_time = t_end - t_start
    core_delaunay_size = get_kcritical_simplextree_size(st)
    results["core_delaunay_time"] = core_delaunay_time
    results["core_delaunay_size"] = core_delaunay_size
    print(f"Computed Delaunay core in {core_delaunay_time:.2f} seconds with size {core_delaunay_size}.")

    # Rhomboid tiling bifiltrations
    homology_dimension = 1
    temp_folder = Path("./temp_rhomboid_tiling")
    temp_folder.mkdir(parents=True, exist_ok=True)
    input_file = temp_folder / "points.txt"
    output_file = temp_folder / "rhomboid_out"
    np.savetxt(input_file, X, fmt="%.18f")

    print("Computing Sliced Rhomboid tiling...")
    t_start = time.time()
    subprocess.run(["rhomboidtiling", str(input_file), str(output_file), str(X.shape[1]), str(k_max), "firep", str(homology_dimension)], capture_output=True, text=True)
    t_end = time.time()
    rhomboid_time = t_end - t_start
    rhomboid_size = get_scc_filtration_size(output_file)
    results["sliced_rhomboid_time"] = rhomboid_time
    results["sliced_rhomboid_size"] = rhomboid_size
    print(f"Computed sliced rhomboid tiling in {rhomboid_time:.2f} seconds with size {rhomboid_size}.")

    print("Computing Unsliced Rhomboid tiling...")
    t_start = time.time()
    subprocess.run(["rhomboidtiling", str(input_file), str(output_file), str(X.shape[1]), str(k_max), "ufirep", str(homology_dimension)], capture_output=True, text=True)
    t_end = time.time()
    rhomboid_time = t_end - t_start
    rhomboid_size = get_scc_filtration_size(output_file)
    results["unsliced_rhomboid_time"] = rhomboid_time
    results["unsliced_rhomboid_size"] = rhomboid_size
    print(f"Computed unsliced rhomboid tiling in {rhomboid_time:.2f} seconds with size {rhomboid_size}.")

    # Clean up temp folder
    print(f"Cleaning up {temp_folder}...")
    shutil.rmtree(temp_folder)

    return results

def uniform_unit_square(n: int, rng: np.random.Generator) -> np.ndarray:
    """Generate n uniformly distributed points in a unit square."""
    return np.random.rand(n, 2)

if __name__ == "__main__":
    seed = 0
    #sizes = [10_000, 20_000, 40_000, 80_000]
    sizes = [100, 200, 400, 800]  # Smaller sizes for quick testing
    ks_max = [4, 8]

    rng = np.random.default_rng(seed)
    all_results = {}

    n_experiments = len(sizes) * len(ks_max)
    current_experiment = 1
    for n in sizes:
        points = uniform_unit_square(n, rng)
        for k_max in ks_max:
            print(f"{current_experiment}/{n_experiments}: n={n}, k_max={k_max}")
            results = benchmark(points, k_max)
            all_results[(n, k_max)] = results
            current_experiment += 1

    print("Final results:")
    for (n, k_max), results in all_results.items():
        print(f"n={n}, k_max={k_max}")
        for key, value in results.items():
            if isinstance(value, float):
                print(f" {key}: {value:.2f}")
            else:
                print(f" {key}: {value}")

#print(f"Reading the output file {output_file} into a Slicer object and computing the minimal presentation...")
#t_start = time.time()
#slicer = mp.Slicer()
#mp.io.scc_reduce_from_str_to_slicer(output_file, slicer, backend="mpfree", dimension=homology_dimension, verbose=False)
#t_end = time.time()
#print(f"Slicer object created and reduced in {t_end - t_start:.2f} seconds.")
